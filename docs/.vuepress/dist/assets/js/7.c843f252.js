(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{377:function(v,_,l){"use strict";l.r(_);var i=l(42),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"css-基础知识"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#css-基础知识"}},[v._v("#")]),v._v(" CSS 基础知识")]),v._v(" "),l("h2",{attrs:{id:"谈谈你对-css-盒模型的理解"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对-css-盒模型的理解"}},[v._v("#")]),v._v(" 谈谈你对 CSS 盒模型的理解？🌟")]),v._v(" "),l("ul",[l("li",[l("strong",[v._v("定义：")]),v._v(" 浏览器会将元素看成一个盒子，CSS 的各种属性来决定这些盒子的大小、位置、颜色等。")]),v._v(" "),l("li",[l("strong",[v._v("分类：")]),v._v(" 标准盒模型和怪异盒模型。\n"),l("ul",[l("li",[v._v("标准盒模型：内容区等于 content，整体为内容区 + padding + border + margin。")]),v._v(" "),l("li",[v._v("怪异盒模型：内容区等于 content + padding + border，整体为内容区 + margin。")])])]),v._v(" "),l("li",[l("strong",[v._v("改变：")]),v._v(" 使用 box-sizing 属性。（content-box 为标准盒模型，border-box 为怪异盒模型）")])]),v._v(" "),l("h2",{attrs:{id:"css-选择器的优先级是怎样的"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#css-选择器的优先级是怎样的"}},[v._v("#")]),v._v(" CSS 选择器的优先级是怎样的？🌟")]),v._v(" "),l("p",[v._v("!important > 内联样式 > ID 选择器 > class 选择器 > 标签选择器 > 通配符选择器 > 继承 > 默认")]),v._v(" "),l("h2",{attrs:{id:"margin-设置负值时有什么影响"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#margin-设置负值时有什么影响"}},[v._v("#")]),v._v(" margin 设置负值时有什么影响？")]),v._v(" "),l("ul",[l("li",[l("strong",[v._v("margin-top：")]),v._v(" 元素向上移动")]),v._v(" "),l("li",[l("strong",[v._v("margin-bottom：")]),v._v(" 下方相邻元素向上移动，自身不受影响。")]),v._v(" "),l("li",[l("strong",[v._v("margin-left：")]),v._v(" 元素向左移动")]),v._v(" "),l("li",[l("strong",[v._v("margin-right：")]),v._v(" 右侧相邻元素向左移动，自身不受影响。")])]),v._v(" "),l("h2",{attrs:{id:"line-height-如何继承"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#line-height-如何继承"}},[v._v("#")]),v._v(" line-height 如何继承？")]),v._v(" "),l("ul",[l("li",[v._v("写具体数值，直接继承该值（如30px）")]),v._v(" "),l("li",[v._v("写比例，则继承该比例（如1.5 / 2）")]),v._v(" "),l("li",[v._v("写百分比，则继承计算出来的值（如200%）")])]),v._v(" "),l("h2",{attrs:{id:"伪类和伪元素是什么"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#伪类和伪元素是什么"}},[v._v("#")]),v._v(" 伪类和伪元素是什么？")]),v._v(" "),l("ul",[l("li",[l("strong",[v._v("伪类：")]),v._v(" "),l("ul",[l("li",[v._v("定义：以一个冒号作为前缀，被添加到一个选择器末尾的字段，当你希望样式在特定状态下才被呈现到指定元素时使用。")]),v._v(" "),l("li",[v._v("常用包括：hover、focus、first-child、nth-child 等。")])])]),v._v(" "),l("li",[l("strong",[v._v("伪元素：")]),v._v(" "),l("ul",[l("li",[v._v("定义：用于创建一些不存在文档树中的元素，并为其添加样式，虽然用户可以看到这些内容，但是在实际的文档中并不存在。")]),v._v(" "),l("li",[v._v("常用包括：before、after等。")])])])]),v._v(" "),l("h2",{attrs:{id:"em、px、rem-等单位的区别"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#em、px、rem-等单位的区别"}},[v._v("#")]),v._v(" em、px、rem 等单位的区别？🌟")]),v._v(" "),l("ul",[l("li",[v._v("px：绝对单位，精确的像素。")]),v._v(" "),l("li",[v._v("em：相对单位，如果自身设置了 font-size 时，1em = font-size 的值；自身未设置时为最近祖先元素的。")]),v._v(" "),l("li",[v._v("rem：相对单位，相对于根结点 html 的 font-size。")]),v._v(" "),l("li",[v._v("vw/vh：相对单位，1vw = 视口宽度的1%；1vh = 视口高度的1%。")])]),v._v(" "),l("h2",{attrs:{id:"css-的定位方式"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#css-的定位方式"}},[v._v("#")]),v._v(" CSS 的定位方式？")]),v._v(" "),l("ul",[l("li",[v._v("static：正常文档流定位。")]),v._v(" "),l("li",[v._v("relative：相对于正常文档流定位。")]),v._v(" "),l("li",[v._v("absolute：相对于最近的非 static 元素进行定位。")]),v._v(" "),l("li",[v._v("fixed：相对于页面视口的位置进行定位，滚动等操作不会对其造成改变。")]),v._v(" "),l("li",[v._v("sticky：粘性定位，当元素在屏幕内是表现为 relative，当元素滚出屏幕时表现为 fixed。")])]),v._v(" "),l("h2",{attrs:{id:"如何理解-z-index"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#如何理解-z-index"}},[v._v("#")]),v._v(" 如何理解 z-index？")]),v._v(" "),l("ul",[l("li",[l("strong",[v._v("作用：")]),v._v(" 用来控制重叠元素的垂直叠加顺序。")]),v._v(" "),l("li",[l("strong",[v._v("表现：")]),v._v(" 默认为0，设置的值越大，垂直位置上的层级越高。")]),v._v(" "),l("li",[l("strong",[v._v("影响元素：")]),v._v(" z-index 只能影响设置了 position 值的元素。")])]),v._v(" "),l("h2",{attrs:{id:"css-有哪些方式可以隐藏元素"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#css-有哪些方式可以隐藏元素"}},[v._v("#")]),v._v(" CSS 有哪些方式可以隐藏元素？")]),v._v(" "),l("ul",[l("li",[l("strong",[v._v("opacity: 0")]),v._v(" 将透明度设为0，元素不可见，占据位置并且可以交互。")]),v._v(" "),l("li",[l("strong",[v._v("visibility: hidden")]),v._v(" 元素设置为隐藏，占据位置但是不可交互。")]),v._v(" "),l("li",[l("strong",[v._v("overflow: hidden")]),v._v(" 元素超出部分的内容设置为隐藏，占据位置但是不可交互。")]),v._v(" "),l("li",[l("strong",[v._v("display: none")]),v._v(" 元素设置为不展示，不占据位置并且不可交互。")]),v._v(" "),l("li",[l("strong",[v._v("transform: scale(0, 0)")]),v._v(" 将元素缩放为0，占据位置但是不可交互。")])]),v._v(" "),l("h2",{attrs:{id:"bfc-及其应用"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#bfc-及其应用"}},[v._v("#")]),v._v(" BFC 及其应用？🌟")]),v._v(" "),l("ul",[l("li",[l("strong",[v._v("定义：")]),v._v(" 全称为块级格式化上下文，实际是一个独立渲染的区域，内部元素不会影响边界以外的元素。")]),v._v(" "),l("li",[l("strong",[v._v("触发条件：")]),v._v(" "),l("ul",[l("li",[v._v("根元素（HTML）")]),v._v(" "),l("li",[v._v("浮动元素")]),v._v(" "),l("li",[v._v("position 为 absolute 或 fixed")]),v._v(" "),l("li",[v._v("overflow 不为 visible")]),v._v(" "),l("li",[v._v("display 为 inline-block、flex、table-cell 等。")])])]),v._v(" "),l("li",[l("strong",[v._v("规则：")]),v._v(" "),l("ul",[l("li",[v._v("内部的 box 会在垂直方向上一个一个排列。")]),v._v(" "),l("li",[v._v("同一个 BFC 的两个相邻元素会发生 margin 重叠。")]),v._v(" "),l("li",[v._v("BFC 区域不会与浮动元素发生重叠。")]),v._v(" "),l("li",[v._v("计算 BFC 的高度时，浮动元素也参与计算。")]),v._v(" "),l("li",[v._v("文字层不会被浮动层覆盖，环绕于周围")])])]),v._v(" "),l("li",[l("strong",[v._v("应用：")]),v._v(" "),l("ul",[l("li",[v._v("清除浮动，防止浮动引起父元素塌陷")]),v._v(" "),l("li",[v._v("防止 margin 重叠")]),v._v(" "),l("li",[v._v("防止元素被浮动元素遮挡")])])])]),v._v(" "),l("h2",{attrs:{id:"如何清除浮动"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#如何清除浮动"}},[v._v("#")]),v._v(" 如何清除浮动？")]),v._v(" "),l("ul",[l("li",[v._v("使用 clear 属性：通过给父元素伪类添加 clear。")]),v._v(" "),l("li",[v._v("创建父元素的 BFC。")]),v._v(" "),l("li",[v._v("给父元素设置高度。")])]),v._v(" "),l("h2",{attrs:{id:"谈谈你对响应式布局的理解"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对响应式布局的理解"}},[v._v("#")]),v._v(" 谈谈你对响应式布局的理解？🌟")]),v._v(" "),l("ul",[l("li",[v._v("定义：同一个页面在不同尺寸屏幕下有不同的布局。")]),v._v(" "),l("li",[v._v("优点：\n"),l("ul",[l("li",[v._v("面对不同大小屏幕的设备灵活性强。")]),v._v(" "),l("li",[v._v("能够快速解决多设备显示问题。")])])]),v._v(" "),l("li",[v._v("缺点：\n"),l("ul",[l("li",[v._v("部分方案代码兼容性差（flex 布局、grid 布局）")]),v._v(" "),l("li",[v._v("部分方案工作量比较大（媒体查询）")])])]),v._v(" "),l("li",[v._v("方案：\n"),l("ul",[l("li",[v._v("media query：媒体查询的方式，针对不同的屏幕信息进行布局。")]),v._v(" "),l("li",[v._v("flex 布局：弹性布局的自适应方式。")]),v._v(" "),l("li",[v._v("grid 布局：网格布局的自适应方式。")]),v._v(" "),l("li",[v._v("百分比形式：通过设置百分比使元素随之变化。")]),v._v(" "),l("li",[v._v("vw/vh：通过视口宽高的百分比布局。")]),v._v(" "),l("li",[v._v("rem：结合 media query 使用，根据不同机型设置根结点的字体大小。")])])])]),v._v(" "),l("h2",{attrs:{id:"谈谈你对媒体查询的理解"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对媒体查询的理解"}},[v._v("#")]),v._v(" 谈谈你对媒体查询的理解？")]),v._v(" "),l("ul",[l("li",[l("strong",[v._v("定义：")]),v._v(" 通过查询用户的设备信息属于哪种类型，让网页能够在不同的设备下展示特定效果。")]),v._v(" "),l("li",[l("strong",[v._v("作用：")]),v._v(" 通常用在解决兼容性问题上。")]),v._v(" "),l("li",[l("strong",[v._v("类型：")]),v._v(" 在 web 应用开发时通常会用到 screen （屏幕）类型，有时调用打印机时会用到 print 类型。")])]),v._v(" "),l("h2",{attrs:{id:"对-flex-布局的理解以及常用属性"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#对-flex-布局的理解以及常用属性"}},[v._v("#")]),v._v(" 对 flex 布局的理解以及常用属性？")]),v._v(" "),l("ul",[l("li",[l("strong",[v._v("理解：")]),v._v(" 目前的 web 应用有不同的设备和分辨率，这时需要响应式的页面设计来满足复杂的布局要求。flex 布局的优势在于我们只需要声明布局应该\n具有的行为，而不需要给出具体的实现方案，浏览器负责完成布局。当布局涉及到不定宽度，各种对齐等场景时，可以优先使用 flex 布局。")]),v._v(" "),l("li",[l("strong",[v._v("容器属性：")]),v._v(" "),l("ul",[l("li",[v._v("flex-direction：确定主轴方向。（row | row-reverse | column | cloumn-reverse）")]),v._v(" "),l("li",[v._v("flex-wrap：确定换行方式。（nowrap | wrap | wrap-reverse）")]),v._v(" "),l("li",[v._v("flex-flow：上面两个属性的结合，默认值为 row nowrap。")]),v._v(" "),l("li",[v._v("justify-content：确定主轴上的对齐方式。（flex-start | flex-end | center | space-between | space-around）")]),v._v(" "),l("li",[v._v("align-items：确定交叉轴上的对齐方式。（flex-start | flex-end | center | baseline | stretch）")]),v._v(" "),l("li",[v._v("align-content：确定多个轴线的对齐方式。（flex-start | flex-end | center | space-between | space-around | stretch）")])])]),v._v(" "),l("li",[l("strong",[v._v("项目属性：")]),v._v(" "),l("ul",[l("li",[v._v("order：确定项目的排列顺序，数值越小排列越靠前。")]),v._v(" "),l("li",[v._v("flex-grow：确定项目的放大比例。\n"),l("ul",[l("li",[v._v("默认为0，存在剩余空间也不会放大。")]),v._v(" "),l("li",[v._v("如果所有项目的 flex-grow 都等于1，就等分剩余空间。")]),v._v(" "),l("li",[v._v("如果其中一个项目为2其他项目都为1，前者占据剩余空间比其他多一倍。")])])]),v._v(" "),l("li",[v._v("flex-shark：确定项目的缩小比例。\n"),l("ul",[l("li",[v._v("默认为1，如果空间不足该项目缩小。")]),v._v(" "),l("li",[v._v("如果所有项目的 flex-shark 都等于1，空间不足时等比例缩小。")]),v._v(" "),l("li",[v._v("如果其中一个项目为0其他项目都为1，空间不足时前者不会缩小。")])])]),v._v(" "),l("li",[v._v("flex-basis：确定在分配多余空间前，项目占据的主轴空间。\n"),l("ul",[l("li",[v._v("浏览器根据这个属性，计算主轴是否有剩余空间，默认为auto。")]),v._v(" "),l("li",[v._v("他可以设为跟 width 或 height 属性相同的值，项目将占据固定空间。")])])]),v._v(" "),l("li",[v._v("flex：是 flex-grow、flex-shark、flex-basis 的简写。\n"),l("ul",[l("li",[v._v("默认值为 flex: 0 1 auto，表示不放大会缩小。")]),v._v(" "),l("li",[v._v("flex:none 时，是 flex: 0 0 auto，表示不放大也不缩小。")]),v._v(" "),l("li",[v._v("flex:auto 时，是 flex: 1 1 auto，表示放大且缩小。")]),v._v(" "),l("li",[v._v("值为一个非负数字时：flex-grow被定义，flex-shark为1，flex-basis 为0%。")]),v._v(" "),l("li",[v._v("值为两个非负数字时：flex-grow 和 flex-shark 依次被定义，flex-basis 为0%。")]),v._v(" "),l("li",[v._v("值为一个长度或者百分比时：flex-basis 被定义，flex-grow 和 flex-shark 为1。")]),v._v(" "),l("li",[v._v("值为一个非负数字和一个长度or百分比时：flex-grow 和 flex-basis 依次被定义，flex-shark 为1。")]),v._v(" "),l("li",[v._v("总结，flex-grow 和 flex-shark 不规定则为1，flex-basis 不规定则为0%。")])])]),v._v(" "),l("li",[v._v("align-self：允许单个项目与其他项目对齐方式不同。（auto | flex-start | flex-end | center | baseline | stretch）")])])])]),v._v(" "),l("h2",{attrs:{id:"对-grid-布局的理解以及常用属性"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#对-grid-布局的理解以及常用属性"}},[v._v("#")]),v._v(" 对 grid 布局的理解以及常用属性？")]),v._v(" "),l("h2",{attrs:{id:"元素水平、垂直、水平垂直居中的方法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#元素水平、垂直、水平垂直居中的方法"}},[v._v("#")]),v._v(" 元素水平、垂直、水平垂直居中的方法？🌟")]),v._v(" "),l("ul",[l("li",[v._v("水平居中：\n"),l("ul",[l("li",[v._v("行内元素水平居中：\n"),l("ul",[l("li",[v._v("text-align: center")])])]),v._v(" "),l("li",[v._v("定宽块级元素水平居中：\n"),l("ul",[l("li",[v._v("margin: 0 auto")]),v._v(" "),l("li",[v._v("left: 50% + margin-left: -width/2")])])]),v._v(" "),l("li",[v._v("不定宽块级元素水平居中：\n"),l("ul",[l("li",[v._v("left: 50% + transform: translateX(-50%);")]),v._v(" "),l("li",[v._v("父元素 display: flex; justify-content: center;")])])])])]),v._v(" "),l("li",[v._v("垂直居中：\n"),l("ul",[l("li",[v._v("行内元素垂直居中：\n"),l("ul",[l("li",[v._v("line-height = height")])])]),v._v(" "),l("li",[v._v("定宽块级元素垂直居中：\n"),l("ul",[l("li",[v._v("top: 50% + margin-top: -height/2")])])]),v._v(" "),l("li",[v._v("不定宽块级元素垂直居中：\n"),l("ul",[l("li",[v._v("top: 50% + transform: translateY(-50%);")]),v._v(" "),l("li",[v._v("父元素 display: flex; align-items: center;")])])])])]),v._v(" "),l("li",[v._v("水平垂直居中：\n"),l("ul",[l("li",[v._v("不定宽不定高元素水平垂直居中：\n"),l("ul",[l("li",[v._v("top: 50%; left: 50%; transform: translate(-50%, -50%);")]),v._v(" "),l("li",[v._v("top: 0; right:0; bottom:0; left: 0; margin: auto;（万能方式，兼容 IE 版本）")]),v._v(" "),l("li",[v._v("父元素 display: flex; justify-content: center; align-items: center;")])])])])])]),v._v(" "),l("h2",{attrs:{id:"谈谈你对雪碧图的理解"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对雪碧图的理解"}},[v._v("#")]),v._v(" 谈谈你对雪碧图的理解？")]),v._v(" "),l("ul",[l("li",[l("strong",[v._v("定义：")]),v._v(" 开发人员将多个小的图片合并到一起后成为雪碧图。")]),v._v(" "),l("li",[l("strong",[v._v("使用：")]),v._v(" 通过每张小图片的 background-size、background-position 进行使用。")]),v._v(" "),l("li",[l("strong",[v._v("优点：")]),v._v(" 减少了加载多张图片时的请求次数。")]),v._v(" "),l("li",[l("strong",[v._v("缺点：")]),v._v(" 维护成本改，后期修改复杂。同时在使用 HTTP2.0时，因为增加了多路复用就不需要考虑 http 请求数。")])]),v._v(" "),l("h2",{attrs:{id:"css3新特性有哪些"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#css3新特性有哪些"}},[v._v("#")]),v._v(" CSS3新特性有哪些？")]),v._v(" "),l("ul",[l("li",[v._v("背景：background-size、background-position 等")]),v._v(" "),l("li",[v._v("边框：border-radius、border-image 等")]),v._v(" "),l("li",[v._v("阴影：文本阴影 text-shadow、元素阴影 box-shadow")]),v._v(" "),l("li",[v._v("伪类选择器：nth-child、first-child、last-child 等")]),v._v(" "),l("li",[v._v("渐变：线性渐变 line-gradient、径向渐变 radial-gradient")]),v._v(" "),l("li",[v._v("2D、3D 变换：移动元素 translate、缩放 scale、旋转 rotate 等")]),v._v(" "),l("li",[v._v("flex 布局")])]),v._v(" "),l("h2",{attrs:{id:"谈谈你对-css-动画与过渡的理解"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对-css-动画与过渡的理解"}},[v._v("#")]),v._v(" 谈谈你对 CSS 动画与过渡的理解？")]),v._v(" "),l("ul",[l("li",[v._v("动画 animation：\n"),l("ul",[l("li",[v._v("animation-name：动画名称")]),v._v(" "),l("li",[v._v("animation-duration：动画间隔")]),v._v(" "),l("li",[v._v("animation-fill-mode：动画静止模式")])])]),v._v(" "),l("li",[v._v("过渡 transition：\n"),l("ul",[l("li",[v._v("transition-property：过渡属性")]),v._v(" "),l("li",[v._v("transition-duration：过渡间隔")]),v._v(" "),l("li",[v._v("transition-delay：过渡延迟")])])]),v._v(" "),l("li",[v._v("动画属性：\n"),l("ul",[l("li",[v._v("translate：偏移")]),v._v(" "),l("li",[v._v("scale：缩放")]),v._v(" "),l("li",[v._v("rotate：旋转")]),v._v(" "),l("li",[v._v("opacity：透明度")])])])]),v._v(" "),l("h2",{attrs:{id:"什么是重绘和回流-重排"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#什么是重绘和回流-重排"}},[v._v("#")]),v._v(" 什么是重绘和回流（重排）？🌟")]),v._v(" "),l("ul",[l("li",[v._v("定义：\n"),l("ul",[l("li",[v._v("重排：当元素的尺寸、大小、位置等发生变化，浏览器绘重新排列页面，此时浏览器会重新计算并进行布局，对性能损耗较大。（重排一定会触发重绘）")]),v._v(" "),l("li",[v._v("重绘：当元素的颜色、背景等一些不会影响布局等样式发生改变，浏览器会重新绘制元素，此时只需要 UI 层面重新绘制，对性能损耗较小。")])])]),v._v(" "),l("li",[v._v("触发重排条件：\n"),l("ul",[l("li",[v._v("页面初次渲染")]),v._v(" "),l("li",[v._v("浏览器窗口大小改变")]),v._v(" "),l("li",[v._v("元素等尺寸、大小、位置发生改变")]),v._v(" "),l("li",[v._v("添加或删除可见的 DOM 节点")]),v._v(" "),l("li",[v._v("激活 CSS 的伪类（如 hover、link 等）")]),v._v(" "),l("li",[v._v("查询某些属性或者调用某些方法（如获取各种高度等）")])])]),v._v(" "),l("li",[v._v("避免方式：\n"),l("ul",[l("li",[v._v("避免使用 table 布局（一个元素改变会引起整个 table 的重排）")]),v._v(" "),l("li",[v._v("将动画效果放在 position 为 absolute 或者 fixed 元素上（使其脱离文档流）")]),v._v(" "),l("li",[v._v("减少 DOM 的操作次数，合并一起操作。")]),v._v(" "),l("li",[v._v("避免频繁通过 JS 来操作样式。")])])])]),v._v(" "),l("h2",{attrs:{id:"常遇到的-css-问题有哪些"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#常遇到的-css-问题有哪些"}},[v._v("#")]),v._v(" 常遇到的 CSS 问题有哪些？")]),v._v(" "),l("ul",[l("li",[v._v("1像素边框问题")]),v._v(" "),l("li",[v._v("使用 rem 画圆，转换为 px 后精度丢失。")])]),v._v(" "),l("h2",{attrs:{id:"_1像素边框问题-750为1px-标准325为0-5px"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_1像素边框问题-750为1px-标准325为0-5px"}},[v._v("#")]),v._v(" 1像素边框问题（750为1px，标准325为0.5px）🌟")]),v._v(" "),l("ul",[l("li",[v._v("采用 transform: scale 加伪类标签")]),v._v(" "),l("li",[v._v("采用阴影模拟边框 box-shadow: 0 0 1px 0 #000 inset（但是颜色会变浅）")]),v._v(" "),l("li",[v._v("采用 svg 图片形式，利用 svg 描边，svg 的1像素不会受到屏幕的影响。")])])])}),[],!1,null,null,null);_.default=t.exports}}]);